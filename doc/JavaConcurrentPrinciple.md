[本文摘自书籍《Java并发编程的艺术》](https://www.amazon.cn/dp/B012NDCEA0/ref=sr_1_1?s=books&ie=UTF8&qid=1523863156&sr=1-1&keywords=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF)
#### 前言
Java代码在编译后变成Java字节码，字节码被类加载器加载到JVM中执行，最终转换为汇编指令在CPU上执行，
所以Java的所有机制都依赖于JVM虚拟机的实现与CPU的指令。
#### monitor
监视锁，每个对象都有一个唯一的monitor，它被内置到Java对象头中，所以也称为内置锁，满足一下约束：
- 同时只能一个线程获得锁
- 线程通过竞争获取该锁
- 当线程调用某对象的wait方法时，此线程会释放该对象的锁，并进入休眠状态，直到其他线程获取到了该对象的锁并调用了notify、notifyAll，
此时休眠的线程需要通过竞争来获取该对象的锁。
- 只有拥有某对象的锁的线程才能调用该对象的notify、notifyAll方法，否则抛出java.lang.IllegalMonitorStateException。
#### volatile
在多线程并发编程中synchronized和volatile都扮演者重要的角色，volatile是轻量级的synchronized，
它在对处理器开发中保证了共享变量的可见性。
可见性意思是当一个线程修改一个共享变量时，另一个线程读取到这个修改的值。
如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，
因为它不会引起线程上下文的切换和调度。
##### volatile的定义
Java语言规范第三版中对volatile的定义如下：Java编程语言允许线程访问共享变量，
为了确保共享变量能被准确和一致的更新，线程应该确保通过拍他所单独获得这个变量。
Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，
Java线程内存模型确保所有线程看到的这个变量的值是一致的。
##### volatile实现原理
对被volatile修饰的变量进行写操作的代码，在生成的汇编代码后会多产生一条以lock为前缀的指令，
Lock前缀的指令在多核处理器下会引发两件事：
- 将当前处理器缓存行的数据回写到系统内存。
- 写回内存的操作会使在其他CPU中缓存了该内存地址的数据无效。
##### synchronized实现原理
synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下三种形式:
- 对于普通同步方法，锁是当前实例对象的锁。
- 对于静态同步方法，锁是当前类的Class对象的锁。
- 对于同步方法块，锁是synchronized括号中的对象的锁。
当一个线程试图访问同步代码块是，它首先必须得到锁，退出或抛出异常时必须释放锁。
###### 代码块的同步
使用monitorenter与monitorexit指令实现，monitorenter指令实在编译后插入到同步块的开始位置，
而monitorexit插入到代码块结束处和一长处，JVM确保每个monitorenter必须有对应的monitorexit与之配对，
线程执行到monitorenter指令时，将会尝试获取对象锁。
#### Java对象头
只要使用synchronized实现同步的地方，使用的锁均是monitor，前面提到了monitor存在Java对象头中，
若对象是数组类型，则虚拟机用三个字宽存储对象头，若对象是非数组类型，则使用2个字宽存储对象头。
对象头包含以下三种数据：
- Mark Word
存储对象的hashCode或锁信息等
- ClassMetadata Address
存储到对象类型数据的指针
- Array length
数组长度（若当前对象是数组）
##### Mark Word
包含对象的HashCode、分代年龄、锁信息等信息。在运行期间，Mark Word内存储的数据会随着锁标志位的变化变化，
这里指的变化指的是结构的变化，也就是当锁标志位变化时，Mark Word内记录的信息可能就没有分代年龄、HashCode了，
下面是32位虚拟机Mark Word结构的变化：
<table align="center">
   <tr>
      <td rowspan="2">锁状态</td>
      <td colspan="2">25bit</td>
      <td rowspan="2">4bit</td>
      <td>1bit</td>
      <td>2bit</td>
   </tr>
   <tr>
      <td >23bit</td>
      <td>2bit</td>
      <td>是否为偏向锁</td>
      <td>锁标志位</td>
   </tr>
   <tr>
      <td>轻量级锁</td>
      <td colspan="4">指向栈中锁记录的指针</td>
      <td>00</td>
   </tr>
   <tr>
      <td>重量级锁</td>
      <td colspan="4">指向互斥量(重量级锁)的指针</td>
      <td>10</td>
   </tr>
   <tr>
      <td>GC标记</td>
      <td colspan="4">空</td>
      <td>11</td>
   </tr>
   <tr>
      <td>偏向锁</td>
      <td>线程ID</td>
      <td>Epoch</td>
      <td>对象分代年龄</td>
      <td>1</td>
      <td>01</td>
   </tr>
   <tr>
      <td>无锁状态</td>
      <td colspan="2">对象HashCode</td>
      <td>对象分代年龄</td>
      <td>0</td>
      <td>01</td>
   </tr>
</table>
下面是64位虚拟机Mark Word结构的变化：
<table>
   <tr>
      <td rowspan="2">锁状态</td>
      <td>25bit</td>
      <td>31bit</td>
      <td>1bit</td>
      <td>4bit</td>
      <td>1bit</td>
      <td>2bit</td>
   </tr>
   <tr>
      <td></td>
      <td></td>
      <td>cms_free</td>
      <td>分代年龄</td>
      <td>偏向锁</td>
      <td>锁标志位</td>
   </tr>
   <tr>
      <td>无锁</td>
      <td>空</td>
      <td>hashCode</td>
      <td></td>
      <td></td>
      <td>0</td>
      <td>01</td>
   </tr>
   <tr>
      <td>偏向锁</td>
      <td colspan="2">ThreadID(54bit) Epoch(2bit)</td>
      <td></td>
      <td></td>
      <td>1</td>
      <td>01</td>
   </tr>
</table>
##### 锁升级与对比
Java SE 1.6中为了减少获得锁释放锁带来的性能消耗，引入了偏向锁、轻量级锁。Java SE 1.6中一共有四种状态，有低到高依次为：
无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会锁着竞争情况逐渐升级。锁可以升级但不可以降级，
这种策略目的是为了提高获得锁和释放锁的效率。
- 偏向锁
大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录中存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作
来加锁和解锁，只需简单的测试一下对象头的Mark Work里是否存储着指向当前线程的偏向锁。若测试成功，表示线程已经
获得了锁；若测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置为1（表示是偏向锁）：若没有设置，
则使用CAS竞争锁；若设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
- 偏向锁的撤销
偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。
偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。
它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，
若线程不处于活动状态，则将对象头设置成无锁状态；若线程任然活着，拥有偏向锁的栈会被执行，
遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Work要么重新偏向于其它线程，
要么恢复到无锁或标记对象不适合作为偏向锁，最后唤醒暂停的线程。
- 关闭偏向锁
偏向锁在Java 6和7中默认启用，但是他在应用程序启动几秒钟之后才激活，如果有必要可以使用JVM参数来关闭延迟：
``
-XX:BiasedLockingStartuoDelay=0
``
- 轻量级锁加锁
线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储记录的空间，并将对象头中的Mark Word复制到锁记录中，
官方成为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，
如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋获取锁。
- 轻量级锁解锁
轻量级锁解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，
表示当前锁存在竞争，锁就会膨胀成重量级锁。因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成
重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁是，都会被阻塞住，当持有锁的线程释放锁之后
会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
- 锁优缺点对比
<table>
    <tr>
      <td>锁</td>
      <td>优点</td>
      <td>缺点</td>
      <td>适用场景</td>
   </tr>
   <tr>
     <td>偏向锁</td>
     <td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
     <td>如果线程存在锁竞争，会带来额外的锁撤销消耗</td>
     <td>适用于只有一个线程访问同步块的场景</td>
   </tr>
   <tr>
     <td>轻量级锁</td>
     <td>竞争的线程不会阻塞，提高了程序的响应速度</td>
     <td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
     <td>追求响应时间；同步块执行速度非常快</td>
   </tr>
   <tr>
        <td>重量级锁</td>
        <td>线程竞争不适用自旋，不会消耗CPU</td>
        <td>线程阻塞，响应时间缓慢</td>
        <td>追求吞吐量；同步块执行时间较长</td>
    </tr>
</table>
##### 原子操作的实现原理
原子（atomic）本意是不能被进一步分割的最小粒子，而原子操作（atomic operation）意为不可被中断的一个或一系列操作。
- 处理如何实现原子操作
